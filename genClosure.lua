local libFunFirst = [[ssc_libs_]]
local msysRootPath = [[E:\]]
local pkgCfgCmd = [[pkg-config --cflags gtk+-3.0 librsvg-2.0 lua]]
local includePathIgnore = 
{
	[[E:\msys64\mingw64\include]],
	[[]]
}
local libsFunFirst =
{
	"gtk_",
	"gdk_",
	"g_",
	"cairo_"
}

local keywordIgnore = 
{
	"cairo_t",
	"cairo_surface_t"
}

local keywordNotInFrontOf = 
{
	";",
	")"
}
local sub = string.sub
local gsub = string.gsub
local find = string.find
local len = string.len
local reverse = string.reverse
----设置路径分隔符
local pF = sub(package.config,1,1)
local pFI
if pF == "\\" then
	pFI = "/"
else
	pFI = "\\"
end

local function fp(p) -- formatPath
	return gsub(gsub(p,pFI,pF),"%s","")
end

local requiredFuns = {}

local function split( str,reps )
    local resultStrList = {}
    string.gsub(str,'[^'..reps..']+',function ( w )
        table.insert(resultStrList,w)
    end)
    return resultStrList
end

local function checkInsert(t,funName)
	local v
	for _,v in ipairs(t) do
		if v[1] == funName then
			v[2] = v[2] + 1
			return false
		end
	end
	table.insert(t,{funName,1})
	return true
end
----[[[[[[[[[[[[[[[[[[搜索文件]]]]]]]]]]]]]]]]]]
print("Searching Source Files...")

local searchProc = io.popen("DIR /B /S *.c")

for fa in searchProc:lines() do
	print("\t" .. fa)
	local f = io.open(fa,"r")
	if f then
		local s = f:read("*a")
		f:close()
		if s then
			local pos = 0
			s = gsub(s,libFunFirst,"")
			for _,v in ipairs(keywordIgnore) do
				s = gsub(s,v,"")
			end
			for _,v in ipairs(libsFunFirst) do
				local ss,se = find(s,v)
				while ss ~= nil do
					local funE = find(s,"%(",ss)
					local hifokw = false
					for _,kw in ipairs(keywordNotInFrontOf) do
						local iofs,iofe = find(s,kw,ss)
						if iofs and iofs < funE then
							hifokw = true
							break
						end
					end
					if funE and not hifokw then
						checkInsert(requiredFuns,sub( s, ss,funE-1))
					end
					ss,se = find(s,v,se)
				end
			end
		end
	else
		print("\t[WARN] Can't open file : " .. s)
	end
end
searchProc:close()

table.sort( requiredFuns,function(a,b) return a[2]<b[2] end)
for _,t in ipairs(requiredFuns) do
	print("\t" .. t[2],t[1])
end
print("\tTotal functions: " .. #requiredFuns)

print("Searching includes path...")

searchProc = io.popen(pkgCfgCmd)
local searchingFile = {}
local flags = searchProc:read("*a")
searchProc:close()

flags = split(flags," ")
for _,c in ipairs(flags) do
	c = fp(c)
	if sub(c,1,len(msysRootPath)+2) == "-I" .. msysRootPath then
		print("\t" .. sub(c,3,-1))
		local pn = true
		for _,pa in ipairs(includePathIgnore) do
			if fp(pa) == fp(sub(c,3,-1)) then
				pn = false
				print("\t\tIgore")
				break
			end
		end
		if pn then
			searchProc = io.popen([[DIR /B /S ]] .. sub(c,3,-1) .. pF .. [[*.h]])
			local nums = 0
			for l in searchProc:lines() do
				local needed = true
				for _,pa in ipairs(searchingFile) do
					if pa == l then
						needed = false
						break
					end
				end
				if needed then
					nums = nums + 1
					table.insert(searchingFile,l)
				end
			end
			print("\t\tAdded " .. nums .. " header files")
		end
	end
end
print("\t\tTotal: " .. #searchingFile)

print("Reading Header Files...")


local function rFind(str,kw,pos)
	local rl = len(str)
	local rst,ren = find(reverse(str),reverse(kw),rl-(pos or 0))
	if rst and ren then
		return rl-rst+1,rl-ren+1
	else
		return nil,nil
	end
end

print("[1/2] Reading Function Prototype...")
local cur = 0
local porotypes = {}
while cur < #searchingFile do
	cur = cur + 1
	print("\t[" .. (math.floor((cur / #searchingFile)*1000)/10) .. "%]\t" .. searchingFile[cur])
	local fp = io.open(searchingFile[cur],"r")
	if fp then
		local fs = fp:read("*a")
		fp:close()
		-- %w+%s+函数名字%s*%([^;]*%f[\n]
		fs = gsub(fs,"%f[#].-%f[\n?]","") -- 清除宏定义
		fs = gsub(fs,"/%*.-%*/","") -- 清除多行注释
		fs = gsub(fs,"%f[//].-%f[\n?]","") -- 清除单行注释
		for _,fuN in ipairs(requiredFuns) do
			local ss,se = find(fs,fuN[1] .. ".-%(.-%)")
			if ss then
				se = find(fs,";",ss)
				table.insert(porotypes,{fuN[1],sub(fs,ss,se)})
					print("\t\tAdded: ",sub(fs,ss,se))
				
			end
		end
	else
		print("\t\t[WARN] Can't open file: " .. searchingFile[cur])
	end
end
print("\tTotal: " .. #porotypes)
print("[2/2] Filter Function...")

local finalFunctions = {}
local output = io.open("outputLibs.h","w")
if output then
	output:write([[/*
Generated by Steve's closure script
*/
]])
	for k,fun in ipairs(porotypes) do
		output:write("// Original function name: ")
		output:write(fun[1])
		output:write("\n")
		output:write(fun[2])
		output:write("\n")
	end
else
	print("\t[WARN] Can't write into file: outputLibs.h")
end
os.exit()

for k,funN in ipairs(porotypes) do
	local hasFun = false
	for kk,sfunN in ipairs(porotypes) do
		if kk >= k then break end
		if funN[1] == sfunN[1] then
			print([[=============================
	Warning:
There is a function repeats, 
which one you want to use?
Type y/n to confirm/decline.]])
			print("Function Name: "..funN[1])
			print("Choosed Function before: ")
			print(sfunN[2])
			print("This newer function: ")
			print(funN[2])
			print("=============================")
			local choise = io.read()
			if choise == "Y" then
				hasFun = false
				print("Confirmed.")
			else
				hasFun = true
				print("Declined.")
			end
			break
		end
	end
	if not hasFun then
		finalFunctions[funN[1]] = funN[2]
	end
end
